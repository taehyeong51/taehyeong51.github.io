---
title: "백준[19236] - 청소년 상어"
excerpt: "백준[19236] - 청소년 상어 문제 풀이 및 후기"

categories:
    - 코딩테스트
tags:
    - python
---

# 1. 문제
[백준[19236]-청소년상어](https://www.acmicpc.net/problem/19236)


# 2. 소스코드
'''python
"""
initialize
4x4 크기 공간에 상어가 들어감
(0,0)에 있는 물고기 먹고 (0,0)의 방향 가지게 됨

물고기 이동
1. 번호 작은 물고기부터 이동
2. 이돟할 수 있는 칸 : 1칸 간격, 빈 칸과 다른 물고기가 있는 칸
이동할 수 없는 칸 : 상어가 있거나 공간의 경계 넘는 칸
만약 이동할 수 없으면 방향 45도 반시계 회전, 7번 회전했는데 없으면 이동 X
3. 물고이 있는 칸으로 이동할 때는 해당 위치의 물고기와 위치 바꿈

상어 이동
1. 방향에 있는 칸으로 이동, 한 번에 여러개 가능, 이동한 칸에 있는 물고기만 먹음
2. 단 상어의 방향은 먹은 물고기의 방향으로 고정
3. 이동할 수 있는 공간 없으면 집으로 감

구해야 하는 것 : 상어가 먹을 수 있는 물고기 번호의 합의 최댓값
"""
import copy
N = 4
# 1. initialize
graph = [list(map(int,input().split())) for _ in range(N)] # 물고기1,방향1,물고기2,방향2...
fish = [[0]*N for _ in range(N)]
directions = [[0]*N for _ in range(N)]
eat = [[0]*N for _ in range(N)]
for r in range(N):
    for c in range(N*2):
        if c % 2 == 0:
            fish[r][c//2] = graph[r][c]
        else:
            directions[r][c//2] = graph[r][c]-1
dr = [1,0,-1,0]
dc = [0,1,0,-1]

dgs_r = [-1,-1,0,1,1,1,0,-1]
dgs_c = [0,-1,-1,-1,0,1,1,1]

# 함수 선언
def show():
    for _ in fish:
        print(_)

def move_fish():
    fish_list = []
    for idx in range(1,17):
        is_fish = False
        for r in range(N):
            if is_fish:
                break
            for c in range(N):
                if fish[r][c] == idx:
                    is_fish = True
                    now_r,now_c = r,c
                    break
        if not is_fish:
            continue
        d_idx = directions[now_r][now_c]
        cnt = 0
        is_movable = False
        while cnt < 8:
            new_r = now_r + dgs_r[d_idx]
            new_c = now_c + dgs_c[d_idx]
            if 0 <= new_r < N and 0 <= new_c < N and fish[new_r][new_c] != -1:
                is_movable = True
                break
            d_idx = (d_idx+1)%8
            cnt += 1
        if is_movable:
            directions[now_r][now_c] = d_idx
            fish[now_r][now_c],fish[new_r][new_c] = fish[new_r][new_c],fish[now_r][now_c]
            directions[now_r][now_c],directions[new_r][new_c] = directions[new_r][new_c],directions[now_r][now_c]


def dfs(r,c,direction,L):

    global res,ans,fish,directions
    if res >= ans:
        ans = res
    move_fish()
    save_fish = copy.deepcopy(fish)
    save_directions = copy.deepcopy(directions)
    now_d = direction

    for i in range(1,4):
        new_r = r + dgs_r[now_d]*i
        new_c = c + dgs_c[now_d]*i
        if 0 <= new_r < N and 0 <= new_c < N and fish[new_r][new_c] != 0:
            poor_fish = fish[new_r][new_c]
            res += poor_fish
            fish[r][c] = 0
            fish[new_r][new_c] = -1
            new_d = directions[new_r][new_c]
            dfs(new_r,new_c,new_d,L+1)
            res -= poor_fish
            fish = copy.deepcopy(save_fish)
            directions = copy.deepcopy(save_directions)

ans = fish[0][0]
fish[0][0] = -1

res = ans

dfs(0,0,directions[0][0],0)
#
print(ans)
'''


# 3. 코드리뷰
각주 참조


# 4. 개선사항
* dfs라고 무조건 visited 배열 만들지 않기
* input 크기 항상 유념하며 문제 풀이하기


# 5. 전체시도
![](./bj19236_trial.png)